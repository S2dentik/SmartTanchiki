#!/usr/local/bin/python3

import curses
import time
import random
import time
import numpy as np

COLOR_GREEN = 1

RECT_WIDTH = 3
RECT_HEIGHT = 2
NUM_CARS_IN_ROW = 4
CAR_WIDTH = RECT_WIDTH * 3
CAR_HEIGHT = RECT_HEIGHT * 4
SPEED = 1
CAR_POSITIONS = [(0, 2), (0, 3), (1, 3), 0, 1, 2, 3]

class Game():
  def __init__(self):
    self.cars = []
    self.player = Car(CAR_WIDTH, curses.LINES - CAR_HEIGHT - 1)
    self.done = False

    curses.start_color()
    curses.init_pair(COLOR_GREEN, curses.COLOR_GREEN, curses.COLOR_BLACK)

  def update(self, action):
    self.drawPlayer()
    self.cars = list(filter(lambda car: car.y < curses.LINES, self.cars))
    if len(self.cars) == 0 or min(self.cars, key=lambda car: car.y).y >= CAR_HEIGHT + 3:
      self.generateRow()
    for car in self.cars:
      car.update()
      car.draw()
    # self.handleKeyPress()
    if action == 0:
      self.player.x = max(0, self.player.x - CAR_WIDTH)
    elif action == 2:
      self.player.x = min((NUM_CARS_IN_ROW - 1) * CAR_WIDTH, self.player.x + CAR_WIDTH)

    self.checkCollision()

    if len(self.cars) < 3:
      return -1

    sorted_cars = sorted(self.cars, key=lambda car: car.y, reverse=True)
    reward = -2 if self.done else 1
    if action == 1 and not self.done:
      reward = 3

    return ((sorted_cars[0].xPosition(), sorted_cars[0].y, sorted_cars[1].xPosition(), sorted_cars[1].y, sorted_cars[2].xPosition(), sorted_cars[2].y, self.player.xPosition()), reward)

  def generateRow(self):
    position = random.choice(CAR_POSITIONS)
    if isinstance(position, int):
      self.cars.append(Car(position * CAR_WIDTH, -CAR_HEIGHT))
    elif isinstance(position, list):
      for value in position:
        self.cars.append(Car(value * CAR_WIDTH, -CAR_HEIGHT))

  # def handleKeyPress(self):
  #   key = screen.getch()
  #   if not key in [curses.KEY_LEFT, curses.KEY_RIGHT]:
  #     return
  #   self.drawPlayer(ch=32)
  #   if key == curses.KEY_LEFT:
  #     self.player.x = max(0, self.player.x - CAR_WIDTH)
  #   elif key == curses.KEY_RIGHT:
  #     self.player.x = min((NUM_CARS_IN_ROW - 1) * CAR_WIDTH, self.player.x + CAR_WIDTH)
  #   self.drawPlayer()

  def drawPlayer(self, ch=178):
    self.player.draw(ch, color=COLOR_GREEN)

  def checkCollision(self):
    for car in self.cars:
      if car.y < curses.LINES - 2 * CAR_HEIGHT + 1 or car.y >= curses.LINES - 2:
        continue
      elif car.x == self.player.x:
        self.done = True

class Car():
  def __init__(self, x, y):
    self.x = x
    self.y = y

  def update(self):
    self.y += 1

  def draw(self, ch=178, color=None):
    c = chr(ch)
    tuples = [
      (self.x + RECT_WIDTH, self.y), 
      (self.x, self.y + RECT_HEIGHT),
      (self.x + 2 * RECT_WIDTH, self.y + RECT_HEIGHT),
      (self.x + RECT_WIDTH, self.y + RECT_HEIGHT * 2),
      (self.x, self.y + RECT_HEIGHT * 3),
      (self.x + 2 * RECT_WIDTH, self.y + RECT_HEIGHT * 3)
    ]
    for t in tuples:
      self.drawRect(RECT_WIDTH, RECT_HEIGHT, t[0], t[1], c, color)
      
  def drawRect(self, width, height, x, y, chr, color=None):
    line = "".join([chr * width])
    for l in range(y, y + height):
      if l < 0:
        continue
      elif l >= curses.LINES:
        return
      if e % 5000 == 0:
        screen.addstr(l, x, line, curses.color_pair(COLOR_GREEN) if color else 0)

  def xPosition(self):
    return self.x // CAR_WIDTH

def initialize():
  stdscr = curses.initscr()
  curses.noecho()
  curses.cbreak()
  stdscr.keypad(True)
  curses.curs_set(0)
  curses.halfdelay(1)

  return stdscr

def end(stdscr):
  curses.nocbreak()
  stdscr.keypad(False)
  curses.echo()

screen = initialize()

EPISODES = 250000
LEARNING_RATE = 0.4
DISCOUNT = 0.8

q_table = np.random.uniform(low=-2, high=0, size=(NUM_CARS_IN_ROW, curses.LINES + 1,  NUM_CARS_IN_ROW, curses.LINES + 1,  NUM_CARS_IN_ROW, curses.LINES + 1, NUM_CARS_IN_ROW, 3))
state = (0, 0, 0, 0, 0, 0, 0)

start_time = time.time()

e = 0

for episode in range(EPISODES):
  e = episode
  game = Game()
  while not game.done:
    action = np.argmax(q_table[state])
    if episode % 5000 == 0:
      time.sleep(0.02)
      screen.clear()
      screen.addstr(50, 50, f"Episode {episode}")
    result = game.update(action)
    if episode % 5000 == 0:
      screen.refresh()
    if isinstance(result, int):
      continue
    new_state, reward = result
    if not game.done:
      max_future_q = np.max(q_table[new_state])
      current_q = q_table[state + (action, )]
      new_q = (1 - LEARNING_RATE) * current_q + LEARNING_RATE * (reward + DISCOUNT * max_future_q)
      q_table[state + (action, )] = new_q
    else:
      q_table[state + (action, )] = -2

    state = new_state

  print(episode)
    
